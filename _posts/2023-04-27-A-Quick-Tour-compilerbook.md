---
layout: post
title:  A Quick Tour to compilerbook
date: 2023-04-27 14:30:30 +0800
category: Compiler
---
## 编译器工具链<br>
一个典型的编译器工具链如下所示。
![编译器工具链](/public/images/compiler_toolchain.png)

- 预处理器处理掉源文件中所有#符号开头的指示语言，比如宏定义、头文件等。
- 编译器以预处理的输出作为输入，经过扫描、解析，执行类型检查和其他语义操作，进行代码优化，最后输出汇编语言。
- 汇编器以编译器输出的汇编语言作为输入，输出对象码。对象码虽然包含了CPU能识别的机器语言指令，但是不知道最终的存储地址。
- 链接器接收对象文件、库文件，并将它们组合成完整的可执行的程序。链接器选择每段代码和数据最终加载的存储位置，并通过写入缺失的地址信息将这些文件链接起来。

## 编译器内部的阶段<br>
Unix编译器的流程如下所示。
![编译器流程](/public/images/compiler_stage.png)

- 扫描器的输入是程序的普通文本，它将独立的字符组合起来形成一个个完整的此法单元。
- 解析器的输入是扫描器输出的一个个词法单元，它将这些词法单元组合成完整的声明和表达式，输出抽象语法树。解析器由语法引导，这里的语法声明了给定语言组成的正式规则。抽象语法树描述了程序的语法结构，也记住了源程序中每个结构出现的地方。
- 语义子程序遍历抽象语法树，根据语言的规则和程序元素间的关系推断程序的语义，输出中间表示。中间表示是汇编代码的简化形式，适用于详细的分析。
- 一至多个优化器应用在中间表示，使得程序更小、更快、更高效。
- 代码生成器将优化的中间表示转换为具体的汇编语言程序。一般而言，代码生成器需要执行寄存器分配来高效地管理有限的硬件寄存器，执行指令选择和序列化来得到最高效的汇编指令序列。

## 编译实例
假设我们要将下面的代码段翻译成汇编形式。

height = (width+56) * factor(foo);

首先，扫描器逐个读取源码文本的字符，识别符号间的边界，发射词法单元序列。每个词法单元都是一个描述每个符号本质和内容的小型数据结构：

